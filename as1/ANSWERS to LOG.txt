server.116
	While at some times programs seem linear, only performing one action at a time, they have made leaps in processing power over the years that now even allow multiple cores. With the pthread_create function we are almost creating a parallel process that can perform not only when called, but is running in conjunction to a method. With the second parameter as NULL, this simply defines this pthread with default attributes. If successful, it will the ID for this pthread at the location passed in by the first argument. As mentioned before this will create a shadow process that can assume the a role just as it does with the doit function. Pthreads can close on command as well as simply finishing its process or function.


server.60  what does this line do? --> len = ntohl(len);

	By using the ntohl function on len, we are trying to convert TCP/IP network bitwise order into host byte order.This is little-endian on Intel processors. 

client.159

This function, sendStr, goes to work after receiving the word that is requested to be echoed along with globals.serverFD for the file descriptor from the function doSend. DoSend first used the inputed command after being called from DoCmd by the user. By checking if there is a connection and making sure there is data after the send command, doSend authorizes the program to jump int the else statement above the send: jump. doString finally saves the string to be sent to the server after saving it into str and passing it into sendStr. The variable len in sendStr is assigned to the length of the string passed in from doSend and checks if it is not equal to zero before continuing. If it is not zero, the function continues to assign nlen to len network byte order as to fix its endian state. By passing in specific parameters to net_writen, it checks if the string is correct for the four byte template as well as with len. If these test pass, the function will return a negative one. However if it does not there is space allocated for buff with malloc of size len. If the bytes returned by read is not equal to len the program frees up the space allocated for buff and returns a negative one. While these checks to written and read check the validity of elements in the user input it also uses the number of bytes produced to find any errors in the transfer ilke loss or repletion of elements. However, if all of these checks work out, the write() function uses the buffer and frees up the allocated memory for buf. If and only if the program has made it this far in the function, it will return a value of 1 back to its original call from doSend.

client.65

Although this function does not initiate the program, it is the gateway for the user so that they could manipulate the program with their input. Firstly, the variables len and ret are initiated to store the size and characters, respectively, of the user's inputs throughout the program. Now for the fun stuff. Since we are running this function to get the users input, we start by zeroing whatever was previously stored in globals.in.data & globals.in.newline in order to keep things organized and easy for debugging. Then ret gets assigned to the stream of input being fed in by the user with the built in function of fgets(); this function not only returns the user input into ret, but also assigns the character array to globals.in.data (from the input stream stdin). If the input received is not empty and not null, the input size is saved to len of type int. However if it is empty, its assigned to zero. The next conditional statement is an "if statement" in which len is tested. If it is not zero it, it passes the tests and the program must check the second condition to see if the last element in globals.in.data is a new line. When both of these conditions are true the n/ at the end of globals.in.data is set to zero and globals.in.newline is set to one. As we exit the if statement, two executions are left in this function, globally storing the length of user input in globals.in.len and returning len for prompt.

server.116